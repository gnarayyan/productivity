### Comprehensive Auth and Sync Flows for Offline-First Productivity App

Below, I outline detailed flows for various authentication (auth) and sync scenarios in your Flutter app. These are based on the Clean Architecture design, using `AuthRepository` for auth decisions, a sync queue (e.g., stored in Hive) for pending operations, and state management (e.g., Riverpod) for reactivity. The app prioritizes online operations when connected (e.g., remote auth/sync first), but falls back to local for offline resilience.

Assumptions:

- **Auth Backend**: Firebase/Supabase/custom API with JWT (access token: short-lived, e.g., 1h; refresh token: long-lived, e.g., 30d).
- **Local Storage**: Hive for data/sync queue, `flutter_secure_storage` for tokens.
- **Sync**: Bi-directional (push local changes to remote, pull remote to local). Conflict resolution: Last-write-wins via timestamps.
- **Triggers**: Auto-sync on connectivity change, app resume, or manual (e.g., button). Use `workmanager` for background.
- **User Feedback**: UI shows "Offline mode", "Syncing...", "Sync failed" via snackbars/badges.
- **Anonymous Mode**: Users can operate as guests (not logged in), with local data. On login, merge/migrate data.

I've categorized scenarios into tables for clarity: one for auth actions (login/signup/logout) and one for sync triggers, cross-referencing states like network, token validity, and data presence. Each flow includes steps, decisions, and error handling.

#### 1. Auth Action Flows (Login, Signup, Logout)

These handle user-initiated auth changes, integrated with sync.

| Scenario                                                                             | Preconditions                                                         | Flow Steps                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| ------------------------------------------------------------------------------------ | --------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **First-time user opens app and tries to login (online)**                            | - Not logged in (no session/tokens).<br>- No local data.<br>- Online. | 1. User navigates to LoginScreen, enters email/password or OAuth (e.g., Google).<br>2. `SignInUseCase` calls `AuthRepository.signIn`.<br>3. Repository: Online → Call remote (e.g., Firebase `signInWithEmailAndPassword`), get access/refresh tokens.<br>4. On success: Cache tokens/user in local storage, set `AuthState.authenticated`.<br>5. Trigger initial sync: Pull remote data (if any) to local.<br>6. UI: Redirect to home, show "Logged in successfully".<br>7. Error: Invalid credentials → Show error message; fallback to guest mode. |
| **First-time user opens app and tries to login (offline)**                           | - Not logged in.<br>- No local data.<br>- Offline.                    | 1. User attempts login.<br>2. Repository: Offline → Cannot auth remotely; no cached credentials → Fail with `OfflineAuthException`.<br>3. UI: Show "Offline: Login requires internet. Continue as guest?"<br>4. If guest: Allow local operations, queue login attempt? (Optional: Store credentials temporarily for auto-login on connect, but risky—avoid for security).<br>5. On connect: Retry remote login, then sync.                                                                                                                            |
| **User not logged in, has added local notes, now wants to login and sync (online)**  | - Guest mode.<br>- Local data exists (unsynced notes).<br>- Online.   | 1. User logs in (as above).<br>2. On success: Cache tokens/user.<br>3. Migrate data: Associate local notes with new user ID (e.g., update entity `userId` field).<br>4. Trigger sync: Push local notes to remote, pull any remote data (merge if conflicts).<br>5. UI: "Logging in... Migrating your notes... Sync complete."<br>6. Error: Email exists but wrong password → Prompt recovery.                                                                                                                                                         |
| **User not logged in, has added local notes, now wants to login and sync (offline)** | - Guest mode.<br>- Local data exists.<br>- Offline.                   | 1. Attempt login → Fail (as offline first-time).<br>2. UI: "Offline login not possible without prior session. Notes saved locally—sync on connect."<br>3. Queue migration/sync for post-login.<br>4. On connect: Complete login, then migrate/push data.                                                                                                                                                                                                                                                                                              |
| **User signs up (first-time account creation, online)**                              | - Not logged in.<br>- May have local data.<br>- Online.               | 1. User enters email/password on SignupScreen.<br>2. `SignUpUseCase` calls repository: Online → Remote signup, get tokens.<br>3. Cache tokens/user.<br>4. If local data: Migrate to new user, sync push/pull.<br>5. UI: "Account created. Syncing data..."                                                                                                                                                                                                                                                                                            |
| **User signs up (offline)**                                                          | - Not logged in.<br>- Offline.                                        | 1. Attempt signup → Fail remotely.<br>2. Queue signup action (store email/password temporarily in encrypted storage).<br>3. Allow guest operations.<br>4. On connect: Process queue—remote signup, cache tokens, migrate/sync data.<br>5. Security note: Delete queued credentials after success; prompt re-entry if fails (e.g., email taken).                                                                                                                                                                                                       |
| **User logged in, wants to logout (online)**                                         | - Logged in (valid session).<br>- Online.                             | 1. `SignOutUseCase` calls repository: Online → Remote signout (e.g., revoke tokens), clear local tokens/user.<br>2. Optional: Clear local data? (No—keep for guest mode, but disassociate userId).<br>3. Set `AuthState.unauthenticated`.<br>4. UI: Redirect to login, "Logged out."                                                                                                                                                                                                                                                                  |
| **User logged in, wants to logout (offline)**                                        | - Logged in.<br>- Offline.                                            | 1. Repository: Offline → Clear local tokens/user only (remote revocation queued).<br>2. Set unauthenticated.<br>3. On connect: Process queue to revoke remotely.<br>4. UI: "Logged out locally. Remote logout pending."                                                                                                                                                                                                                                                                                                                               |
| **Password changed (from another device/session)**                                   | - Logged in.<br>- Tokens may be invalid.                              | 1. On app open/action: Check token validity (e.g., during sync attempt).<br>2. If access expired: Try refresh.<br>3. If refresh fails (password changed invalidates refresh token): Force logout, prompt re-login.<br>4. UI: "Session invalid—password may have changed. Please log in again."<br>5. Post re-login: Sync data.                                                                                                                                                                                                                        |

#### 2. Sync Trigger Flows

These handle data sync (notes/tasks), triggered manually, on connect, or background. Auth state influences sync.

| Scenario                                                           | Preconditions                                                                  | Flow Steps                                                                                                                                                                                                                                                                                                                                                                                 |
| ------------------------------------------------------------------ | ------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **User already logged in (valid session), wants to sync (online)** | - Logged in.<br>- Valid access token.<br>- Local changes pending.<br>- Online. | 1. Trigger `SyncDataUseCase` (manual button or auto).<br>2. Repository: Online → Validate access token; if expired, refresh using refresh token.<br>3. Process sync queue: Push local creates/updates/deletes to remote.<br>4. Pull remote changes to local (merge conflicts via timestamps).<br>5. UI: Progress indicator → "Sync complete."<br>6. Error: Refresh fails → Force re-login. |
| **User already logged in (valid session), sync (offline)**         | - Logged in.<br>- Offline.                                                     | 1. Attempt sync → Detect offline → Skip remote, but allow local operations.<br>2. Queue changes locally.<br>3. UI: "Offline: Changes saved locally. Will sync when online."                                                                                                                                                                                                                |
| **Access token expired, refresh token valid (online sync)**        | - Logged in.<br>- Access expired, refresh valid.<br>- Online.                  | 1. Sync attempt → Token check fails.<br>2. `RefreshTokenUseCase`: Use refresh token to get new access token via remote.<br>3. Cache new tokens.<br>4. Retry sync (push/pull).<br>5. UI: Seamless (no interruption unless refresh fails).                                                                                                                                                   |
| **Access token expired, refresh token valid (offline sync)**       | - Logged in.<br>- Access expired.<br>- Offline.                                | 1. Sync attempt → Offline → Use local data; cannot refresh.<br>2. Queue changes.<br>3. On connect: Refresh tokens first, then sync.<br>4. If action requires valid token (rare offline), prompt "Connect to refresh session."                                                                                                                                                              |
| **Both access and refresh tokens expired (online sync)**           | - Logged in (stale session).<br>- Both expired.<br>- Online.                   | 1. Sync attempt → Refresh fails.<br>2. Force logout: Clear local tokens, set unauthenticated.<br>3. UI: "Session expired. Please log in again to sync."<br>4. Post re-login: Resume sync.                                                                                                                                                                                                  |
| **Both tokens expired (offline sync)**                             | - Logged in (stale).<br>- Both expired.<br>- Offline.                          | 1. Sync attempt → Offline → Cannot validate/refresh; assume local session for operations.<br>2. Queue changes.<br>3. UI: "Offline mode active. Session may expire—connect to check."<br>4. On connect: Attempt refresh → Fails → Force re-login, then sync.                                                                                                                                |
| **User not logged in, sync attempt**                               | - Unaenticated (guest).<br>- Local data exists.                                | 1. Sync trigger → Check auth: Not logged in → Skip remote sync.<br>2. UI: "Log in to sync data across devices."<br>3. Allow local operations; on login, migrate/sync as above.                                                                                                                                                                                                             |
| **User logged in on multiple devices (conflict during sync)**      | - Logged in.<br>- Online.<br>- Changes on both local/remote.                   | 1. Sync: Pull remote first, compare timestamps.<br>2. If conflict (same note edited): Apply last-write-wins or prompt user (e.g., "Merge changes?").<br>3. Push local after pull.<br>4. UI: If prompt needed, show dialog with diffs.                                                                                                                                                      |
| **App resume/background sync (logged in, online)**                 | - Logged in.<br>- App in background.<br>- Online.                              | 1. `workmanager` task: Check connectivity → If online, refresh token if needed.<br>2. Process sync queue quietly.<br>3. Notification: If changes pulled, show "Data updated" (via `flutter_local_notifications`).                                                                                                                                                                          |
| **App resume/background sync (offline to online transition)**      | - Any auth state.<br>- From offline to online.                                 | 1. `connectivity_plus` listener detects change.<br>2. If logged in: Refresh token if expired, then sync.<br>3. If not logged in: Skip sync, but if queued actions (e.g., signup), process.<br>4. UI: "Connected—syncing..."                                                                                                                                                                |

#### Additional States and Edge Cases

- **Network Flaky (intermittent online)**: Use Dio's retry interceptor (exponential backoff) for remote calls. Queue failures.
- **Token Revoked (e.g., security breach)**: Remote calls fail → Force logout on next attempt.
- **User Deletes Account Remotely**: On sync, detect (e.g., 403 error) → Logout, clear local data, prompt "Account deleted."
- **Offline for Long Period**: Tokens expire naturally → On connect, force re-login.
- **Guest to Logged In Upgrade**: Always migrate local data on first login (update entities with userId).
- **Password Recovery**: Handle via remote (online only), then re-login and sync.
- **Multi-Account Support (future scale)**: Extend repository to handle multiple users, but for personal app, single session suffices.

These flows ensure robustness: Prioritize user productivity (never block offline), secure auth (no plain passwords locally), and scalable code (abstracted layers). Implement with tests for each scenario (e.g., mock connectivity). If adding biometrics (e.g., `local_auth`), layer it on local token access for quicker offline login.
